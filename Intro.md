# Intro

Haskell 与其他语言不同，是一门纯粹函数式编程语言 (purely functional programming language)。在一般常见的命令式语言中，要运行操作的话是给电脑一组命令，而状态会随着命令的运行而改变。例如你指派变量 a 的值为 5，而随后做了其它一些事情之后 a 就可能变成的其它值。有控制流程 (control flow)，你就可以重复运行操作。然而在纯粹函数式编程语言中，你不是像命令式语言那样命令电脑「要做什么」，而是通过用函数来描述出问题「是什么」，如「阶乘是指从1到某个数的乘积」，「一个串列中数字的和」是指把第一个数字跟剩余数字的和相加。你用声明函数是什么的形式来写程序。另外，变量 (variable) 一旦被指定，就不可以更改了，你已经说了 a 就是 5，就不能再另说 a 是别的什么数。 所以说，在纯粹函数式编程语言中的函数能做的唯一事情就是利用参数计算结果，不会产生所谓的"副作用 (side effect)" 一开始会觉得这限制很大，不过这也是他的优点所在：若以同样的参数调用同一个函数两次，得到的结果一定是相同。这被称作“引用透明 (Referential Transparency)_” (译注：这就跟数学上函数的使用一样)。如此一来编译器就可以理解程序的行为，你也很容易就能验证一个函数的正确性，继而可以将一些简单的函数组合成更复杂的函数。


Haskell 是惰性 (lazy) 的。也就是说若非特殊指明，函数在真正需要结果以前不会被求值。再加上引用透明，你就可以把程序仅看作是数据的一系列变形。如此一来就有了很多有趣的特性，如无限长度的数据结构。一切只需要遍历一次 list 即可，而且仅在你真正需要结果时才会运行。惰性语言中的计算只是一组初始数据和变换公式。

Haskell 是静态类型 (statically typed) 的。Haskell 拥有一套强大的类型系统，支持自动类型推导 (type inference)。类型推导可以让你的程序更加简练。假设有个函数是将两个数值相加，你不需要声明其类型，这个函数可以对一切可以相加的值进行计算。
Haskell 采纳了很多高端编程语言的概念，因而它的代码优雅且简练。与同层次的命令式语言相比，Haskell 的代码往往会更短，更短就意味着更容易理解，bug 也就更少。

**List**

在 Haskell 中，List 就像现实世界中的购物单一样重要。它是最常用的数据结构，并且十分强大，灵活地使用它可以解决很多问题。本节我们将对 List，字符串和 list comprehension 有个初步了解。 在 Haskell 中，List 是一种单类型的数据结构，可以用来存储多个类型相同的元素。我们可以在里面装一组数字或者一组字符，但不能把字符和数字装在一起。

在使用 ++ 运算符处理长字符串时要格外小心(对长 List 也是同样)，Haskell 会遍历整个的 List(++ 符号左边的那个)。在处理较短的字符串时问题还不大，但要是在一个 5000 万长度的 List 上追加元素，那可得运行好一会儿了。所以说，用 : 运算符往一个 List 前端插入元素会是更好的选择。

** Use Range**

今天如果想得到一个包含 1 到 20 之间所有数的 List，你会怎么做? 我们可以将它们一个一个用键盘打出来，但很明显地这不是一个完美的方案，特别是你追求一个好的编程语言的时候。我们想用的是区间 (Range)。Range 是构造 List 方法之一，而其中的值必须是可枚举的，像 1、2、3、4...字符同样也可以枚举，字母表就是 A..Z 所有字符的枚举。而名字就不可以枚举了，"john" 后面是谁？我不知道。
要得到包含 1 到 20 中所有自然数的 List，只要 [1..20] 即可，这与用手写 [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20] 是完全等价的。其实用手写一两个还不是什么大事，但若是手写一个非常长的 List 那就铁定是个笨方法。

尽管 Range 很聪明，但它恐怕还满足不了一些人对它的期许。你就不能通过 [1,2,4..100]这样的语句来获得所有 2 的幂。一方面是因为步长只能标明一次，另一方面就是仅凭前几项，数组的后项是不能确定的。要得到 20 到 1 的 List，[20..1] 是不可以的。必须得 [20,19..1]。 在 Range 中使用浮点数要格外小心！出于定义的原因，浮点数并不精确。

取前 24 个 13 的倍数该怎样？恩，你完全可以 [13,26..24*13]，但有更好的方法： take 24 [13,26..]。
由于 Haskell 是惰性的，它不会对无限长度的 List 求值，否则会没完没了的。它会等着，看你会从它那儿取多少。在这里它见你只要 24 个元素，便欣然交差。如下是几个生成无限 List 的函数 cycle 接受一个 List 做参数并返回一个无限 List 。如果你只是想看一下它的运算结果而已，它会运行个没完的。所以应该在某处划好范围。

取前 24 个 13 的倍数该怎样？恩，你完全可以 [13,26..24*13]，但有更好的方法： take 24 [13,26..]。
由于 Haskell 是惰性的，它不会对无限长度的 List 求值，否则会没完没了的。它会等着，看你会从它那儿取多少。在这里它见你只要 24 个元素，便欣然交差。如下是几个生成无限 List 的函数 cycle 接受一个 List 做参数并返回一个无限 List 。如果你只是想看一下它的运算结果而已，它会运行个没完的。所以应该在某处划好范围。

repeat 接受一个值作参数，并返回一个仅包含该值的无限 List。这与用 cycle 处理单元素 List 差不多。

若只是想得到包含相同元素的 List ，使用 replicate 会更简单，如 replicate 3 10，得 [10,10,10]。

**List Comprehension**

前十个偶数的 set comprehension 可以表示为，竖线左端的部分是输出函数，x 是变量，N 是输入集合。

从一个 List 中筛选出符合特定限制条件的操作也可以称为过滤 (filtering)。即取一组数并且按照一定的限制条件过滤它们。

若非在 ghci 之下，还是将 List Comprehension 分成多行好，尤其是需要嵌套的时候。

**Tuple**

从某种意义上讲，Tuple (元组)很像 List --都是将多个值存入一个个体的容器。但它们却有着本质的不同，一组数字的 List 就是一组数字，它们的类型相同，且不关心其中包含元素的数量。而 Tuple 则要求你对需要组合的数据的数目非常的明确，它的类型取决于其中项的数目与其各自的类型。Tuple 中的项由括号括起，并由逗号隔开。
另外的不同之处就是 Tuple 中的项不必为同一类型，在 Tuple 里可以存入多态别项的组合。
在 Haskell 中表示二维矢量该如何？使用 List 是一种方法，它倒也工作良好。若要将一组矢量置于一个 List 中来表示平面图形又该怎样？我们可以写类似 [[1,2],[8,11],[4,5]] 的代码来实现。但问题在于，[[1,2],[8,11,5],[4,5]] 也是同样合法的，因为其中元素的类型都相同。尽管这样并不靠谱，但编译时并不会报错。然而一个长度为 2 的 Tuple (也可以称作序对，Pair) ，是一个独立的类型，这便意味着一个包含一组序对的 List 不能再加入一个三元组，所以说把原先的方括号改为圆括号使用 Tuple 会 更好: [(1,2),(8,11),(4,5)]。若试图表示这样的图形： [(1,2),(8,11,5),(4,5)]，就会报出错误.

使用 Tuple 前应当事先明确一条数据中应该由多少个项。每个不同长度的 Tuple 都是独立的类型，所以你就不可以写个函数来给它追加元素。而唯一能做的，就是通过函数来给一个 List 追加序对，三元组或是四元组等内容。
可以有单元素的 List，但 Tuple 不行。想想看，单元素的 Tuple 本身就只有一个值，对我们又有啥意义？不靠谱。
同 List 相同，只要其中的项是可比较的，Tuple 也可以比较大小，只是你不可以像比较不同长度的 List 那样比较不同长度的 Tuple 。

有个函数很 cool，它就是 zip。它可以用来生成一组序对 (Pair) 的 List。它取两个 List，然后将它们交叉配对，形成一组序对的 List。它很简单，却很实用，尤其是你需要组合或是遍历两个 List 时。

考虑一个同时应用到 List 和 Tuple 的问题：如何取得所有三边长度皆为整数且小于等于 10，周长为 24 的直角三角形？首先，把所有三边长度小于等于 10 的三角形都列出来：

    ghci> let triangles = [ (a,b,c) | c <- [1..10], b <- [1..10], a <- [1..10] ]

从三个 List 中取值，并且通过输出函数将其组合为一个三元组。只要在 ghci 下边调用 triangle，你就会得到所有三边都小于等于 10 的三角形。我们接下来给它添加一个限制条件，令其必须为直角三角形。同时也考虑上 b 边要短于斜边，a 边要短于 b 边情况：
ghci> let rightTriangles = [ (a,b,c) | c <- [1..10], b <- [1..c], a <- [1..b], a^2 + b^2 == c^2]
已经差不多了。最后修改函数，告诉它只要周长为 24 的三角形。
ghci> let rightTriangles' = [ (a,b,c) | c <- [1..10], b <- [1..c], a <- [1..b], a^2 + b^2 == c^2, a+b+c == 24]
ghci> rightTriangles'
[(6,8,10)]